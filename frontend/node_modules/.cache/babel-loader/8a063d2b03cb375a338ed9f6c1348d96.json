{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nimport React from 'react';\nexport var addAccessibility = function addAccessibility(children, slidesToShow) {\n  if (slidesToShow > 1) {\n    return React.Children.map(children, function (child) {\n      return React.cloneElement(child, child.props);\n    });\n  } else {\n    // when slidesToshow is 1\n    return React.Children.map(children, function (child) {\n      return React.cloneElement(child, child.props);\n    });\n  }\n};\nexport var getValidChildren = function getValidChildren(children) {\n  // .toArray automatically removes invalid React children\n  return React.Children.toArray(children);\n};\n\nvar getMax = function getMax(a, b) {\n  return a > b ? a : b;\n};\n\nvar getHeightOfSlide = function getHeightOfSlide(slide) {\n  if (!slide) {\n    return 0;\n  }\n\n  if (slide.children && slide.children.length > 0) {\n    // Need to convert slide.children from HTMLCollection\n    // to an array\n    var children = _toConsumableArray(slide.children);\n\n    return children.reduce(function (totalHeight, child) {\n      return totalHeight + child.offsetHeight;\n    }, 0);\n  } else {\n    return slide.offsetHeight;\n  }\n}; // end - is exclusive\n\n\nexport var findMaxHeightSlideInRange = function findMaxHeightSlideInRange(slides, start, end) {\n  var maxHeight = 0;\n\n  if (slides.length === 0 || start < 0 || end < 0 || start > slides.length - 1 || end > slides.length) {\n    return maxHeight;\n  }\n\n  if (start < end) {\n    for (var i = start; i < end; i++) {\n      maxHeight = getMax(getHeightOfSlide(slides[i]), maxHeight);\n    }\n  } else if (start > end) {\n    // Finding max in a wrap around\n    for (var _i = start; _i < slides.length; _i++) {\n      maxHeight = getMax(getHeightOfSlide(slides[_i]), maxHeight);\n    }\n\n    for (var _i2 = 0; _i2 < end; _i2++) {\n      maxHeight = getMax(getHeightOfSlide(slides[_i2]), maxHeight);\n    }\n  } else {\n    // start === end\n    maxHeight = getHeightOfSlide(slides[start]);\n  }\n\n  return maxHeight;\n};\nexport var findCurrentHeightSlide = function findCurrentHeightSlide(currentSlide, slidesToShow, alignment, wrapAround, slides) {\n  if (slidesToShow > 1) {\n    var startIndex = currentSlide;\n    var lastIndex = Math.min(Math.ceil(slidesToShow) + currentSlide, slides.length);\n    var offset = alignment === 'center' ? (slidesToShow - 1) / 2 : slidesToShow - 1;\n\n    switch (alignment) {\n      case 'center':\n        startIndex = Math.floor(currentSlide - offset);\n        lastIndex = Math.ceil(currentSlide + offset) + 1;\n        break;\n\n      case 'right':\n        startIndex = Math.floor(currentSlide - offset);\n        lastIndex = currentSlide + 1;\n        break;\n\n      case 'left':\n        startIndex = Math.floor(currentSlide + offset);\n        lastIndex = Math.ceil(currentSlide + offset) + 1;\n        break;\n    } // inclusive\n\n\n    startIndex = wrapAround && startIndex < 0 ? slides.length + startIndex : Math.max(startIndex, 0); // exclusive\n\n    lastIndex = wrapAround && lastIndex > slides.length ? lastIndex - slides.length : Math.min(lastIndex, slides.length);\n    return findMaxHeightSlideInRange(slides, startIndex, lastIndex);\n  } else {\n    return getHeightOfSlide(slides[currentSlide]);\n  }\n};\nexport var calculateSlideHeight = function calculateSlideHeight(props, state) {\n  var childNodes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var heightMode = props.heightMode,\n      vertical = props.vertical,\n      initialSlideHeight = props.initialSlideHeight,\n      wrapAround = props.wrapAround;\n  var slidesToShow = state.slidesToShow,\n      currentSlide = state.currentSlide,\n      cellAlign = state.cellAlign;\n  var firstSlide = childNodes[0];\n\n  if (firstSlide && heightMode === 'first') {\n    return vertical ? getHeightOfSlide(firstSlide) * slidesToShow : getHeightOfSlide(firstSlide);\n  }\n\n  if (heightMode === 'max') {\n    return findMaxHeightSlideInRange(childNodes, 0, childNodes.length);\n  }\n\n  if (heightMode === 'current') {\n    return findCurrentHeightSlide(currentSlide, slidesToShow, cellAlign, wrapAround, childNodes);\n  }\n\n  return initialSlideHeight || 100;\n};","map":{"version":3,"sources":["/mnt/c/Users/antr9/Desktop/studypal-master/node_modules/nuka-carousel/es/utilities/bootstrapping-utilities.js"],"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Object","prototype","toString","call","Array","from","isArray","i","arr2","length","React","addAccessibility","children","slidesToShow","Children","map","child","cloneElement","props","getValidChildren","toArray","getMax","a","b","getHeightOfSlide","slide","reduce","totalHeight","offsetHeight","findMaxHeightSlideInRange","slides","start","end","maxHeight","_i","_i2","findCurrentHeightSlide","currentSlide","alignment","wrapAround","startIndex","lastIndex","Math","min","ceil","offset","floor","max","calculateSlideHeight","state","childNodes","arguments","undefined","heightMode","vertical","initialSlideHeight","cellAlign","firstSlide"],"mappings":"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","sourcesContent":["function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nimport React from 'react';\nexport var addAccessibility = function addAccessibility(children, slidesToShow) {\n  if (slidesToShow > 1) {\n    return React.Children.map(children, function (child) {\n      return React.cloneElement(child, child.props);\n    });\n  } else {\n    // when slidesToshow is 1\n    return React.Children.map(children, function (child) {\n      return React.cloneElement(child, child.props);\n    });\n  }\n};\nexport var getValidChildren = function getValidChildren(children) {\n  // .toArray automatically removes invalid React children\n  return React.Children.toArray(children);\n};\n\nvar getMax = function getMax(a, b) {\n  return a > b ? a : b;\n};\n\nvar getHeightOfSlide = function getHeightOfSlide(slide) {\n  if (!slide) {\n    return 0;\n  }\n\n  if (slide.children && slide.children.length > 0) {\n    // Need to convert slide.children from HTMLCollection\n    // to an array\n    var children = _toConsumableArray(slide.children);\n\n    return children.reduce(function (totalHeight, child) {\n      return totalHeight + child.offsetHeight;\n    }, 0);\n  } else {\n    return slide.offsetHeight;\n  }\n}; // end - is exclusive\n\n\nexport var findMaxHeightSlideInRange = function findMaxHeightSlideInRange(slides, start, end) {\n  var maxHeight = 0;\n\n  if (slides.length === 0 || start < 0 || end < 0 || start > slides.length - 1 || end > slides.length) {\n    return maxHeight;\n  }\n\n  if (start < end) {\n    for (var i = start; i < end; i++) {\n      maxHeight = getMax(getHeightOfSlide(slides[i]), maxHeight);\n    }\n  } else if (start > end) {\n    // Finding max in a wrap around\n    for (var _i = start; _i < slides.length; _i++) {\n      maxHeight = getMax(getHeightOfSlide(slides[_i]), maxHeight);\n    }\n\n    for (var _i2 = 0; _i2 < end; _i2++) {\n      maxHeight = getMax(getHeightOfSlide(slides[_i2]), maxHeight);\n    }\n  } else {\n    // start === end\n    maxHeight = getHeightOfSlide(slides[start]);\n  }\n\n  return maxHeight;\n};\nexport var findCurrentHeightSlide = function findCurrentHeightSlide(currentSlide, slidesToShow, alignment, wrapAround, slides) {\n  if (slidesToShow > 1) {\n    var startIndex = currentSlide;\n    var lastIndex = Math.min(Math.ceil(slidesToShow) + currentSlide, slides.length);\n    var offset = alignment === 'center' ? (slidesToShow - 1) / 2 : slidesToShow - 1;\n\n    switch (alignment) {\n      case 'center':\n        startIndex = Math.floor(currentSlide - offset);\n        lastIndex = Math.ceil(currentSlide + offset) + 1;\n        break;\n\n      case 'right':\n        startIndex = Math.floor(currentSlide - offset);\n        lastIndex = currentSlide + 1;\n        break;\n\n      case 'left':\n        startIndex = Math.floor(currentSlide + offset);\n        lastIndex = Math.ceil(currentSlide + offset) + 1;\n        break;\n    } // inclusive\n\n\n    startIndex = wrapAround && startIndex < 0 ? slides.length + startIndex : Math.max(startIndex, 0); // exclusive\n\n    lastIndex = wrapAround && lastIndex > slides.length ? lastIndex - slides.length : Math.min(lastIndex, slides.length);\n    return findMaxHeightSlideInRange(slides, startIndex, lastIndex);\n  } else {\n    return getHeightOfSlide(slides[currentSlide]);\n  }\n};\nexport var calculateSlideHeight = function calculateSlideHeight(props, state) {\n  var childNodes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var heightMode = props.heightMode,\n      vertical = props.vertical,\n      initialSlideHeight = props.initialSlideHeight,\n      wrapAround = props.wrapAround;\n  var slidesToShow = state.slidesToShow,\n      currentSlide = state.currentSlide,\n      cellAlign = state.cellAlign;\n  var firstSlide = childNodes[0];\n\n  if (firstSlide && heightMode === 'first') {\n    return vertical ? getHeightOfSlide(firstSlide) * slidesToShow : getHeightOfSlide(firstSlide);\n  }\n\n  if (heightMode === 'max') {\n    return findMaxHeightSlideInRange(childNodes, 0, childNodes.length);\n  }\n\n  if (heightMode === 'current') {\n    return findCurrentHeightSlide(currentSlide, slidesToShow, cellAlign, wrapAround, childNodes);\n  }\n\n  return initialSlideHeight || 100;\n};"]},"metadata":{},"sourceType":"module"}