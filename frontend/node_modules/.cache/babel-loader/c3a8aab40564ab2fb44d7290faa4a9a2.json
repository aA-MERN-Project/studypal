{"ast":null,"code":"'use strict';\n\nvar template = require('string-template');\n\nvar assert = require('assert');\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar isWordBoundary = /[_.-](\\w|$)/g;\nvar FUNCTION_FIELD_WHITELIST = Object.getOwnPropertyNames(TypedError);\nmodule.exports = TypedError;\n\nfunction TypedError(args) {\n  assert(args, 'TypedError: must specify options');\n  assert(args.type, 'TypedError: must specify options.type');\n  assert(args.message, 'TypedError: must specify options.message');\n  assert(!has(args, 'fullType'), 'TypedError: fullType field is reserved');\n  var message = args.message;\n  var funcName = args.name;\n\n  if (!funcName) {\n    var errorName = camelCase(args.type) + 'Error';\n    funcName = errorName[0].toUpperCase() + errorName.substr(1);\n  }\n\n  var copyArgs = {};\n  extend(copyArgs, args);\n\n  for (var i = 0; i < FUNCTION_FIELD_WHITELIST.length; i++) {\n    delete copyArgs[FUNCTION_FIELD_WHITELIST[i]];\n  }\n\n  extend(createError, copyArgs);\n  createError._name = funcName;\n  return createError;\n\n  function createError(opts) {\n    var result = new Error();\n    Object.defineProperty(result, 'type', {\n      value: result.type,\n      enumerable: true,\n      writable: true,\n      configurable: true\n    });\n    var options = {};\n    extend(options, args);\n    extend(options, opts);\n\n    if (!options.fullType) {\n      options.fullType = options.type;\n    }\n\n    result.name = funcName;\n    extend(result, options);\n\n    if (opts && opts.message) {\n      result.message = template(opts.message, options);\n    } else if (message) {\n      result.message = template(message, options);\n    }\n\n    return result;\n  }\n}\n\nfunction extend(target, source) {\n  for (var key in source) {\n    if (hasOwnProperty.call(source, key)) {\n      target[key] = source[key];\n    }\n  }\n}\n\nfunction camelCase(str) {\n  return str.replace(isWordBoundary, upperCase);\n}\n\nfunction upperCase(_, x) {\n  return x.toUpperCase();\n}\n\nfunction has(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}","map":{"version":3,"sources":["/mnt/c/Users/antr9/Desktop/studypal-master/frontend/node_modules/error/typed.js"],"names":["template","require","assert","hasOwnProperty","Object","prototype","isWordBoundary","FUNCTION_FIELD_WHITELIST","getOwnPropertyNames","TypedError","module","exports","args","type","message","has","funcName","name","errorName","camelCase","toUpperCase","substr","copyArgs","extend","i","length","createError","_name","opts","result","Error","defineProperty","value","enumerable","writable","configurable","options","fullType","target","source","key","call","str","replace","upperCase","_","x","obj"],"mappings":"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","sourcesContent":["'use strict';\n\nvar template = require('string-template');\nvar assert = require('assert');\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar isWordBoundary = /[_.-](\\w|$)/g;\n\nvar FUNCTION_FIELD_WHITELIST = Object.getOwnPropertyNames(TypedError)\n\nmodule.exports = TypedError;\n\nfunction TypedError(args) {\n    assert(args, 'TypedError: must specify options');\n    assert(args.type, 'TypedError: must specify options.type');\n    assert(args.message, 'TypedError: must specify options.message');\n\n    assert(!has(args, 'fullType'),\n        'TypedError: fullType field is reserved');\n\n    var message = args.message;\n    var funcName = args.name\n    if (!funcName) {\n        var errorName = camelCase(args.type) + 'Error';\n        funcName = errorName[0].toUpperCase() + errorName.substr(1);\n    }\n\n    var copyArgs = {}\n    extend(copyArgs, args)\n    for (var i = 0; i < FUNCTION_FIELD_WHITELIST.length; i++) {\n        delete copyArgs[FUNCTION_FIELD_WHITELIST[i]]\n    }\n\n    extend(createError, copyArgs);\n    createError._name = funcName;\n\n    return createError;\n\n    function createError(opts) {\n        var result = new Error();\n\n        Object.defineProperty(result, 'type', {\n            value: result.type,\n            enumerable: true,\n            writable: true,\n            configurable: true\n        });\n\n        var options = {}\n        extend(options, args)\n        extend(options, opts)\n        if (!options.fullType) {\n            options.fullType = options.type;\n        }\n\n        result.name = funcName\n        extend(result, options);\n        if (opts && opts.message) {\n            result.message = template(opts.message, options);\n        } else if (message) {\n            result.message = template(message, options);\n        }\n\n        return result;\n    }\n}\n\nfunction extend(target, source) {\n    for (var key in source) {\n        if (hasOwnProperty.call(source, key)) {\n            target[key] = source[key]\n        }\n    }\n}\n\nfunction camelCase(str) {\n    return str.replace(isWordBoundary, upperCase);\n}\n\nfunction upperCase(_, x) {\n    return x.toUpperCase();\n}\n\nfunction has(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\n"]},"metadata":{},"sourceType":"script"}